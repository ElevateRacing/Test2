<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elevate Racing - New Dimension of Go-Kart Racing</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="wrapper">
        <div id="logo">
            <img src="logo.png" alt="Logo" style="max-height: 50px;">
        </div>
        <div id="top-text">
            <span class="first-word">Air Kart</span> <span class="rest-words"> - Probably* the coolest kart you can fly</span>
        </div>
        <div id="left-text">
            <div><span class="regular">Mass of kart </span> <span class="bold">150kg</span></div>
            <div><span class="regular">and pilot </span> <span class="bold">100kg MAX</span></div>
            <div><span class="regular">Flight time </span> <span class="bold">15min</span></div>
            <hr class="separator">
            <div><span class="regular">8x Electric motors </span> <span class="bold">130hp</span></div>
            <div><span class="regular">8x Battery </span> <span class="bold">100V/21Ah</span></div>
            <hr class="separator">
            <div class="spacer"></div>
            <div class="spacer"></div>
            <div><span class="regular">Estimated purchase price:</span> <span class="bold">$199,000</span></div>
        </div>
        <div id="canvas-container"></div>
        <div id="right-text">
            <div><span class="bold">CFRP</span> <span class="regular"> monocoque contruction</span></div>
            <div><span class="regular">designed for </span> <span class="bold">pilots safety</span></div>
            <hr class="separator">
            <div><span class="regular">Components made from </span></div>
            <div><span class="bold">environmental friendly</span> <span class="regular"> flax fibre</span></div>
            <hr class="separator">
            <div><span class="regular">Ducted propeller for </span> <span class="bold">increased</span></div>
            <div><span class="bold">efficiency</span> <span class="regular"> and </span> <span class="bold">noise reduction</span></div>
        </div>
        <div id="bottom-text">*Disclaimer - we know its the coolest kart</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/TrackballControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/geometries/DecalGeometry.js"></script>
    <script>
        // Scene, camera, and renderer setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setClearColor(0xD3D3D3, 1);
        //renderer.autoClear = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Better color/contrast
        renderer.toneMappingExposure = 1.0; // Adjust exposure
        renderer.physicallyCorrectLights = true; // Realistic light falloff
        
        const container = document.getElementById('canvas-container');
        const leftText = document.getElementById('left-text');
        const rightText = document.getElementById('right-text');
        const topText = document.getElementById('top-text');
        const bottomText = document.getElementById('bottom-text');
        const logo = document.getElementById('logo');
        const wrapper = document.getElementById('wrapper');

       if (!container) {
            console.error('Canvas container not found! Add <div id="canvas-container"></div> to your HTML.');
        } else {
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
        } 
        
        // Add coordinate axes
        const axesHelper = new THREE.AxesHelper(1); // Size of 1 unit
        scene.add(axesHelper);
        
        // Load HDRI environment map
        const rgbeLoader = new THREE.RGBELoader();
        rgbeLoader.load(
            'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/autumn_field_1k.hdr', // Example HDRI from Poly Haven
            function (texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping; // Required for HDRI
                scene.environment = texture; // Apply to materials for reflections
                // scene.background = texture; // Uncomment to set as background (optional)
                console.log('HDRI environment loaded successfully!');
            },
            undefined,
            function (error) {
                console.error('Error loading HDRI:', error);
            }
        );


        
        // Add ambient lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 2);
        scene.add(ambientLight);

        // Add directional lighting
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 2);
        directionalLight1.position.set(-3, -3, 3);
        scene.add(directionalLight1);

        // Add helper to visualize the directional light
        const lightHelper1 = new THREE.DirectionalLightHelper(directionalLight1, 1); // Size of helper = 1 unit
        scene.add(lightHelper1);
/*
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight2.position.set(-5, 5, -5);
        scene.add(directionalLight2);

        // Add helper to visualize the directional light
        const lightHelper2 = new THREE.DirectionalLightHelper(directionalLight2, 1); // Size of helper = 1 unit
        scene.add(lightHelper2);

        const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight3.position.set(0, -5, 5);
        scene.add(directionalLight3);

        // Add helper to visualize the directional light
        const lightHelper3 = new THREE.DirectionalLightHelper(directionalLight3, 1); // Size of helper = 1 unit
        scene.add(lightHelper3);

        const pointLight = new THREE.PointLight(0xffffff, 0.3, 50);
        pointLight.position.set(0, 5, 5);
        scene.add(pointLight);
*/
        // Load the model and add decals
        let model; // To store the loaded OBJ for decal application
        const mtlLoader = new THREE.MTLLoader();
        mtlLoader.load(
            'Mono.mtl',
            function (materials) {
                materials.preload();

                const objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.load(
                    'Mono.obj',
                    function (object) {
                        model = object; // Store the model
                        scene.add(model);
                        model.position.set(0, 0, 0);
                        model.scale.set(0.001, 0.001, 0.001);

                        console.log('Model loaded successfully!');
                        console.log('Object structure:', model);

                        // Calculate and log model dimensions
                        const boundingBox = new THREE.Box3().setFromObject(model);
                        const size = new THREE.Vector3();
                        boundingBox.getSize(size); // Get dimensions
                        console.log('Model Dimensions (width, height, depth):', 
                            size.x.toFixed(3), size.y.toFixed(3), size.z.toFixed(3));

                        // Center of the model
                        const center = new THREE.Vector3();
                        boundingBox.getCenter(center);
                        console.log('Model Center (x, y, z):', 
                            center.x.toFixed(3), center.y.toFixed(3), center.z.toFixed(3));

                        // Optional: Add a visual bounding box helper
                        const boxHelper = new THREE.Box3Helper(boundingBox, 0xffff00); // Yellow box
                        scene.add(boxHelper);
                        
                        // Apply PBR material tweaks
                        model.traverse(child => {
                            if (child.isMesh) {
                                if (!child.material || child.material.color.getHex() === 0x000000) {
                                    child.material = new THREE.MeshStandardMaterial({
                                        color: 0xcccccc,
                                        roughness: 0.3,
                                        metalness: 0.5,
                                        envMap: scene.environment,
                                        envMapIntensity: 2.0
                                    });
                                } else {
                                    child.material.roughness = 0.3;
                                    child.material.metalness = 0.5;
                                    child.material.envMap = scene.environment;
                                    child.material.envMapIntensity = 2.0;
                                }
                                child.material.needsUpdate = true;
                            }
                        });

                        // Add decal after model is loaded
                        addDecal();
                    },
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    function (error) {
                        console.error('Error loading Mono.obj:', error);
                    }
                );
            },
            function (xhr) {
                console.log('MTL ' + (xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading Mono.mtl:', error);
            }
        );

        // Function to add a decal
        function addDecal() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                '55.png', // Path to your decal image
                function (decalTexture) {
                    // Decal material (alphaTest for transparency)
                    const decalMaterial = new THREE.MeshPhongMaterial({
                        map: decalTexture,
                        transparent: true,
                        alphaTest: 0.1, // Adjust to cut off transparency edges
                        depthTest: true,
                        depthWrite: false,
                        polygonOffset: true,
                        polygonOffsetFactor: -4 // Prevents z-fighting
                    });

                    // Decal position, orientation, and size
                    const position = new THREE.Vector3(0, -0.005, 0.5); // Adjust X, Y, Z to position on model
                    const orientation = new THREE.Euler(0, 0, 0); // Rotation in radians (X, Y, Z)
                    const size = new THREE.Vector3(0.015, 0.015, 0.015); // Width, height, depth of projection

                    // Apply decal to each mesh in the model
                    model.traverse(child => {
                        if (child.isMesh) {
                            const decalGeometry = new THREE.DecalGeometry(child, position, orientation, size);
                            const decal = new THREE.Mesh(decalGeometry, decalMaterial);
                            scene.add(decal);
                        }
                    });
                },
                undefined,
                function (error) {
                    console.error('Error loading decal texture:', error);
                }
            );
        }




                

        // Position the camera
        camera.position.z = 1;

      // Add TrackballControls for unrestricted rotation
        const controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 2.0;    // Speed of rotation
        controls.zoomSpeed = 1.2;      // Speed of zooming
        controls.panSpeed = 0.8;       // Speed of panning
        controls.staticMoving = false; // Smooth movement (dynamic damping)
        controls.dynamicDampingFactor = 0.05; // Damping strength
        controls.minDistance = 0.5;      // Minimum zoom distance
        controls.maxDistance = 3;     // Maximum zoom distance

        function resizeRenderer() {
            const totalWidth = wrapper.clientWidth;
            const leftWidth = leftText ? leftText.offsetWidth : 0;
            const rightWidth = rightText ? rightText.offsetWidth : 0;
            const canvasWidth = totalWidth - leftWidth - rightWidth;

            renderer.setSize(canvasWidth, container.clientHeight);
            camera.aspect = canvasWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        }

        resizeRenderer();
        window.addEventListener('resize', resizeRenderer);

        const observer = new MutationObserver(resizeRenderer);
        [logo, topText, leftText, rightText, bottomText].forEach(element => {
            if (element) observer.observe(element, { childList: true, subtree: true, characterData: true });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.clear();
            renderer.render(scene, camera);
        }
        animate();
        </script>
</body>
</html>
